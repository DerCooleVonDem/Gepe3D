

        // two particles forming the connecting edge, then the two on both sides
        private List<(Particle, Particle, Particle, Particle)> bendConstraints;
                
                foreach ( (Particle, Particle, Particle, Particle) constraint in bendConstraints )
                {
                    // p1 is considered 0 and ignored, the other positions are relative to p1
                    Vector3 p2 = constraint.Item2.posEstimate - constraint.Item1.posEstimate;
                    Vector3 p3 = constraint.Item3.posEstimate - constraint.Item1.posEstimate;
                    Vector3 p4 = constraint.Item4.posEstimate - constraint.Item1.posEstimate;
                    
                    float w1 = constraint.Item1.inverseMass;
                    float w2 = constraint.Item2.inverseMass;
                    float w3 = constraint.Item3.inverseMass;
                    float w4 = constraint.Item4.inverseMass;
                    
                    Vector3 cross1 = Vector3.Cross( p2, p3 );
                    Vector3 cross2 = Vector3.Cross( p2, p4 );
                    float crossLen1 = cross1.Length;
                    float crossLen2 = cross2.Length;
                    Vector3 normal1 = cross1.Normalized();
                    Vector3 normal2 = cross2.Normalized();
                    
                    float d = Vector3.Dot( normal1, normal2 );
                    
                    Vector3 q3 = ( Vector3.Cross(p2, normal2) + Vector3.Cross(normal1, p2) * d ) / crossLen1;
                    Vector3 q4 = ( Vector3.Cross(p2, normal1) + Vector3.Cross(normal2, p2) * d ) / crossLen2;
                    Vector3 q2 = 
                        - ( Vector3.Cross(p3, normal2) + Vector3.Cross(normal1, p3) * d ) / crossLen1
                        - ( Vector3.Cross(p4, normal1) + Vector3.Cross(normal2, p4) * d ) / crossLen2;
                    Vector3 q1 = - q2 - q3 - q4;
                    
                    float denominatorSum =
                        w1 * Vector3.Dot(q1, q1) +
                        w2 * Vector3.Dot(q2, q2) +
                        w3 * Vector3.Dot(q3, q3) +
                        w4 * Vector3.Dot(q4, q4);
                    
                    float defaultAngle = MathF.PI;
                    float term = MathF.Sqrt(1 - d * d) * (MathF.Acos(d) - defaultAngle) / denominatorSum;
                    
                    Vector3 correction1 = - w1 * q1 * term;
                    Vector3 correction2 = - w2 * q2 * term;
                    Vector3 correction3 = - w3 * q3 * term;
                    Vector3 correction4 = - w4 * q4 * term;
                    
                    constraint.Item1.posEstimate += correction1 * bendStiffness;
                    constraint.Item2.posEstimate += correction2 * bendStiffness;
                    constraint.Item3.posEstimate += correction3 * bendStiffness;
                    constraint.Item4.posEstimate += correction4 * bendStiffness;
                    
                }
                
                
        
        private static readonly (Vector2i, Vector2i, Vector2i, Vector2i)[] bends = 
        {
            ( new Vector2i(0, 0), new Vector2i(1, 0), new Vector2i(0, -1), new Vector2i(1, 1) ) ,
            ( new Vector2i(0, 0), new Vector2i(0, 1), new Vector2i(-1, 1), new Vector2i(1, 0) ) ,
        };
                
                
                foreach ( (Vector2i, Vector2i, Vector2i, Vector2i) bend in bends)
                {
                    Vector2i c1 = coord + bend.Item1;
                    Vector2i c2 = coord + bend.Item2;
                    Vector2i c3 = coord + bend.Item3;
                    Vector2i c4 = coord + bend.Item4;
                    
                    if (
                        c1.X < xRes && c2.X < xRes && c3.X < xRes && c4.X < xRes &&
                        c1.Y < zRes && c2.Y < zRes && c3.Y < zRes && c4.Y < zRes &&
                        c1.X >= 0 && c2.X >= 0 && c3.X >= 0 && c4.X >= 0 &&
                        c1.Y >= 0 && c2.Y >= 0 && c3.Y >= 0 && c4.Y >= 0
                    ) {
                        Particle p1 = particles[ coord2id(c1, xRes, zRes) ];
                        Particle p2 = particles[ coord2id(c2, xRes, zRes) ];
                        Particle p3 = particles[ coord2id(c3, xRes, zRes) ];
                        Particle p4 = particles[ coord2id(c4, xRes, zRes) ];
                        simulator.AddBendConstraint(p1, p2, p3, p4);
                        p1.constraintCount++;
                        p2.constraintCount++;
                        p3.constraintCount++;
                        p4.constraintCount++;
                    }
                }